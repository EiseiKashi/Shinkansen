package  {
	import flash.display.Graphics;
	import flash.display.MovieClip;
	import flash.display.Shape;
	import flash.events.Event;
	import flash.events.KeyboardEvent;
	import flash.geom.Point;

	public class Camera {
		public static var PI2:Number = Math.PI * 2;
		
		private var _cameraAsset:CameraAsset = new CameraAsset();
		private var _fixCamera:CameraAsset   = new CameraAsset();
		private var _render:Function;
		
		private var _itemsList:Array      = new Array();
		private var _map:MovieClip        = new MovieClip();
		private var _inverseMap:MovieClip = new MovieClip();
		private var _debugger:Debugger    = new Debugger();
		
		private var _depth:Number         = 0;
		private var _radian:Number        = 0;
		private var _radianFraction:Number;
		private var _focalLength:Number   = 300;
		
		private var _offsetX:Number       = 0;
		private var _offsetY:Number       = 0;
		private var _cameraX:Number       = 0;
		private var _cameraOffsetX:Number = 0;
		private var _cameraOffsetY:Number = 0;
		private var _cameraZ:Number       = 0;
		
		public function Camera() {
			_render      = render1;
			_inverseMap.addChild(new GridAsset());
			_inverseMap.addChild(_cameraAsset);
			focalLength = _focalLength;
			_map.addChild(new GridAsset());
			
		}
		
		public function addItem(item:Sprite3D):void {
			var name:String      = "id_" + String(_itemsList.length);
			_itemsList.push(item);
			
			_itemsList.sortOn("z", Array.DESCENDING | Array.NUMERIC); 
			
			var point:PointAsset = new PointAsset();
				point.name		 = name;
				point.x          = item.x;
				point.y          = item.z;
				point.indexT.text = item.id;
			_map.addChild(point);
			
			var point1:PointAsset = new PointAsset();
				point1.x          = point.x;
				point1.y          = point.y;
				point1.indexT.text = item.id;
			_inverseMap.addChild(point1);
			
			_inverseMap.setChildIndex(_cameraAsset, _inverseMap.numChildren - 1);
			
			_render();
		}
		
		public function get cameraX(): Number{
			return _cameraOffsetX;
		}
		
		public function set cameraX(value:Number):void {
			_cameraOffsetX = value;
			_render();
		}
		
		public function set radian(value:Number):void {
			_radian = value;
			updateComponent();
			_render();
		}
		public function get radian():Number {
			return _radian;
		}
		
		public function set cameraZ(value:Number):void {
			if (isNaN(value)) {
				return;
			}
			_depth = value;
			updateComponent();
			_render();
		}
		
		public function get cameraZ():Number {
			return _depth;
		}
		
		
		
		public function get map():MovieClip {
			return _map;
		}
		
		public function get focalLength():Number {
			return _focalLength;
		}
		
		public function set focalLength(value:Number):void {
			if (isNaN(value)) {
				return;
			}
			_focalLength = value;
			_cameraAsset.focal.height = _focalLength * 2;
			_cameraAsset.camera.y     = _cameraAsset.focal.height/2;
			_render();
		}
		
		public function get offsetX():Number {
			return _offsetX;
		}
		
		public function set offsetX(value:Number):void {
			_offsetX = value;
		}
		
		public function get offsetY():Number {
			return _offsetY;
		}
		
		public function set offsetY(value:Number):void {
			_offsetY = value;
		}
		
		public function get inverseMap():MovieClip {
			return _inverseMap;
		}
		
		public function get debugger():Debugger {
			return _debugger;
		}
		
		private function render0():void {
			var view:MovieClip;
			var dx:Number;
			var dy:Number;
			var x:Number;
			var y:Number;
			var z:Number;
			var itemRadian:Number;
			var radius:Number;
			var item:Sprite3D;
			var point:MovieClip;
			var scaleFactor:Number;
			var name:String
			var index:uint  = 0;
			var length:uint = _itemsList.length;
			while (index < length) {
				item    = _itemsList[index];
				view    = item.view;
				name    = "id_" + String(index);
				point   = MovieClip(_map.getChildByName(name));
				
				var div:Number = (item.x - _cameraX) / _depth;
				dx      = item.x - _cameraX + _cameraOffsetX;
				dy      = item.z - _cameraZ;
				
				itemRadian = Math.atan2(dy,dx) + _radian;
				radius     = Math.sqrt(dx*dx + dy*dy);
				
				x = Math.cos(itemRadian) * radius;
				y = item.y - _cameraOffsetY;
				z = Math.sin(itemRadian) * radius;
				
				point.x = x;
				point.y = z;
				
				item.cameraZ = z;
				scaleFactor  = _focalLength / (_focalLength + z);
				
				if(scaleFactor > 0) {
					view.visible = true;
					view.x       = (x * scaleFactor) + _offsetX;
					view.y       = (y * scaleFactor) + _offsetY;
					view.scaleX  = scaleFactor;
					view.scaleY  = scaleFactor;
				}else {
					view.visible = false;
				}
				
				index++
			}
			
			_itemsList.sortOn("cameraZ", Array.DESCENDING | Array.NUMERIC);
			
			index  = 0;
			length = _itemsList.length; 
			while (index < length) {
				item    = _itemsList[index];
				view    = item.view;
				view.parent.setChildIndex(view, index);
				index++
			}
			
			displayMap();
		}
		
		private function render1():void {
			var view:MovieClip;
			var dx:Number;
			var dy:Number;
			var x:Number;
			var y:Number;
			var z:Number;
			var itemRadian:Number;
			var radius:Number;
			var item:Sprite3D;
			var point:MovieClip;
			var scaleFactor:Number;
			var name:String
			var index:uint  = 0;
			var length:uint = _itemsList.length;
			while (index < length) {
				item    = _itemsList[index];
				view    = item.view;
				name    = "id_" + String(index);
				point   = MovieClip(_map.getChildByName(name));
				
				dx      = item.x + _cameraOffsetX - _cameraX;
				dy      = item.z -  _cameraZ;
				
				itemRadian = Math.atan2(dy,dx) + _radian;
				radius     = Math.sqrt(dx*dx + dy*dy);
				
<<<<<<< .mine
				x = _cameraX + (Math.cos(itemRadian) * radius);
				z = _cameraZ + (Math.sin(itemRadian) * radius);
				
				x = Math.cos(itemRadian) * radius + _cameraOffsetX;
=======
				x = Math.cos(itemRadian) * radius;
>>>>>>> .r5393
				y = item.y - _cameraOffsetY;
				z = Math.sin(itemRadian) * radius;
				
				point.x = x;
				point.y = z;
				
				item.cameraZ = z;
				scaleFactor  = _focalLength / (_focalLength + z);
				
				if(scaleFactor > 0) {
					view.visible = true;
					view.x       = (x * scaleFactor) + _offsetX;
					view.y       = (y * scaleFactor) + _offsetY;
					view.scaleX  = scaleFactor;
					view.scaleY  = scaleFactor;
					view["foreground"].alpha   = scaleFactor;
					view["scaleT"].text  = String(int(scaleFactor*100));
				}else {
					view.visible = false;
				}
				
				index++
			}
			
			_itemsList.sortOn("cameraZ", Array.DESCENDING | Array.NUMERIC);
			
			index  = 0;
			length = _itemsList.length; 
			while (index < length) {
				item    = _itemsList[index];
				view    = item.view;
				view.parent.setChildIndex(view, index);
				index++
			}
			
			displayMap();
		}
		
		private function displayMap():void {
			var item:Sprite3D;
			var index:uint  = 0;
			var length:uint = 0;
			
			_cameraAsset.rotation = getAngle(radian);
			_cameraAsset.x        = _cameraX;
			_cameraAsset.y        = _cameraZ;
			
			_debugger.xT.text    = String(_cameraX);
			_debugger.yT.text    = String("---");
			_debugger.zT.text    = String(_cameraZ);
			
			_debugger.offXT.text = String(_cameraOffsetX);
			_debugger.offYT.text = String(_cameraOffsetY);
			_debugger.offZT.text = "---";
			
			_map.addChild(_fixCamera);
			_fixCamera.x = _cameraX;
			_fixCamera.y = _cameraZ;
			
		}
		
		private function updateComponent():void {
			_cameraX  = Math.sin(_radian) * (_depth);
			_cameraZ  = Math.cos(_radian) * (_depth);
		}
		
		private function getHipotenuse(dx:Number, dy:Number):Number {
			var hypotenuse:Number =  Math.sqrt(dx * dx + dy * dy);
			return hypotenuse;
		}
		
		private function getRadian (degree:Number):Number{
			return degree * (PI2/360);
		}
		
		private function getAngle(radian:Number):Number {
			return radian * (360/PI2);
		}
		
		private function drawLine(mc:MovieClip, origin:Point, destiny:Point, color:Number, clear:Boolean):void {
			var graphics:Graphics = mc.graphics;
			if (clear) {
				graphics.clear();
			}
			graphics.moveTo(origin.x, origin.y);
			graphics.lineTo(origin.x, origin.y);
			graphics.lineTo(destiny.x, destiny.y)
		}
	}
}